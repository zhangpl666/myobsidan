# 核心概念：异常是什么？

异常是程序运行时发生的 “错误事件”（比如除零、索引越界、文件不存在），如果不处理，程序会直接崩溃并抛出错误信息。

错误处理的目标：**捕获异常→处理异常（或抛出自定义异常）→保证程序不崩溃 / 优雅退出**。

---

# 👀处理异常！
## 基础结构try-except
`try` 包裹 “可能出错的代码”，`except` 捕获指定异常并处理，是最基础的异常处理组合。

### 基本语法：
```python
try:
    # 可能触发异常的代码块（核心逻辑）
    危险代码
except 异常类型1:
    # 捕获到“异常类型1”时执行的处理逻辑
    处理逻辑1
except 异常类型2 as e:
    # 捕获到“异常类型2”时执行，e 是异常对象（可查看错误详情）
    处理逻辑2
except:
    # 捕获所有未被上面捕获的异常（兜底，不推荐滥用）
    兜底处理逻辑
```
try这一部分是一定会执行的，如果没有抛出异常，那么就优雅结束，若抛出异常，那么会根据捕获的异常类型进行下面except的处理

举个例子：
```python
# 场景：计算两数相除，处理“除零异常”和“类型错误”
def divide(a, b):
    try:
        return a / b
    except ZeroDivisionError as e:
        # 捕获“除数为0”的异常，e 打印错误详情
        print(f"错误：除数不能为0！错误详情：{e}")
    except TypeError as e:
        # 捕获“类型不匹配”的异常（比如传入字符串）
        print(f"错误：请传入数字！错误详情：{e}")

divide(10, 0)  # 输出：错误：除数不能为0！错误详情：division by zero
divide(10, "5")  # 输出：错误：请传入数字！错误详情：unsupported operand type(s) for /: 'int' and 'str'
```
#### 关键注意点

- **精准捕获异常**：优先捕获具体异常（如 `ZeroDivisionError`），而非直接用 `except:` 兜底（会隐藏未知错误，不利于调试）。
- **异常对象 e**：`as e` 可获取异常的具体信息（如错误原因、堆栈），方便排查问题。

## else字句：无异常执行
`else` 跟在所有 `except` 之后，仅当 `try` 代码块**没有触发任何异常**时执行。
作用：分离 “核心逻辑” 和 “无异常时的附加逻辑”，让代码更清晰。
```python
def divide(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        print("错误：除数不能为0")
    else:
        # 仅当 try 无异常时执行
        print(f"计算成功！结果：{result}")
        return result

divide(10, 2)  # 输出：计算成功！结果：5.0
divide(10, 0)  # 输出：错误：除数不能为0（else 不执行）
```

## finally子句：无论是否异常都执行
`finally` 跟在所有 `except/else` 之后，**无论 try 块是否触发异常**，最终都会执行。

核心场景：释放资源（如关闭文件、关闭数据库连接、释放锁），避免资源泄漏。

```python
# 场景：读取文件，无论是否读取成功，最终都关闭文件
file_path = "test.txt"
try:
    f = open(file_path, "r")
    content = f.read()
    print(f"文件内容：{content}")
except FileNotFoundError:
    print(f"错误：文件 {file_path} 不存在")
finally:
    # 无论是否触发异常，都关闭文件（避免文件句柄泄漏）
    if 'f' in locals():  # 先判断文件对象是否存在
        f.close()
        print("文件已关闭")
```
`finally` 即使遇到 `return`/`break` 也会执行：
```python
def test():
    try:
        return 1
    finally:
        print("finally 执行了")

print(test())  # 先输出“finally 执行了”，再输出 1
```

## raise：主动抛出异常
`raise` 用于**手动触发异常**，适用于：

1. 自定义业务异常（比如 “输入的年龄小于 0”）；
2. 捕获异常后，补充信息再重新抛出（不吞异常）。
### 抛出自定义异常：
```python
# 场景：校验年龄，小于0则主动抛异常
def check_age(age):
    if age < 0:
        # 主动抛出 ValueError，可自定义错误信息
        raise ValueError(f"年龄不能为负数！你输入的是：{age}")
    print(f"年龄校验通过：{age}")

# 调用（未处理异常会直接崩溃）
check_age(-5)  # 抛出：ValueError: 年龄不能为负数！你输入的是：-5
```
### 捕获后重新抛出
```python
# 场景：捕获基础异常，包装成更易理解的业务异常再抛出
def divide(a, b):
    try:
        return a / b
    except ZeroDivisionError as e:
        # 捕获系统异常，补充业务信息后重新抛出
        raise ValueError("业务错误：除数不能为0，请检查输入") from e  # from e 保留原始异常栈

# 调用（需处理重新抛出的异常）
try:
    divide(10, 0)
except ValueError as e:
    print(e)  # 输出：业务错误：除数不能为0，请检查输入
    # 打印原始异常栈（方便调试）
    import traceback
    traceback.print_exc()
```
### 注意点

- `raise` 后不跟参数：可在 `except` 中重新抛出当前捕获的异常（保留原始信息）；
- `from e`：保留原始异常的堆栈信息，便于定位根因（推荐使用）。