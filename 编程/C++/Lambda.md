# 是什么
Lambda 表达式是 C++11 引入的核心特性，本质是**匿名的函数对象（闭包）** —— 编译器会自动生成一个匿名**类**（称为 “闭包类型”），Lambda 实例就是这个类的对象，重载了 `operator()` 实现函数调用逻辑。它的核心价值是**简化临时、短小的函数逻辑**，替代传统的函数指针、伪函数（函数对象），让代码更简洁、内聚。
# 定位与本质

### 1. 核心作用

- 就地定义 “临时函数”，无需单独声明 / 定义普通函数 / 伪函数；
- 支持捕获外部变量（局部变量、this 指针等），实现 “带状态的临时函数”；
- 兼容 STL 算法（如 `std::sort`、`std::for_each`）、回调函数、异步逻辑等场景。

### 2. 本质：匿名闭包类型的实例

Lambda 不是 “函数指针”，而是编译器生成的**匿名类（闭包类型）** 的实例：

- 每个 Lambda 有唯一的匿名类型（无法显式写出，需用 `auto` 或 `std::function` 存储）；
- 若 Lambda 无捕获（`[]`），可**隐式转换**为匹配签名的函数指针（C++11 特性）；
- 若 Lambda 有捕获，无法转换为函数指针（需用 `std::function` 封装）。

# 完整语法（C++十一及以上）
```cpp
[capture子句] (参数列表) mutable noexcept -> 返回值类型 { 函数体 }
```
各部分含义：

|部分|作用|
|---|---|
|`[capture]`|捕获子句：指定捕获外部变量的方式（空 `[]` 表示无捕获）|
|`(parameters)`|参数列表：和普通函数的参数列表一致（比如 `(int)` 表示接收一个 int 参数）|
|`mutable`|可选：允许修改按值捕获的变量（默认不能修改）|
|`noexcept`|可选：声明 Lambda 不会抛出异常|
|`-> return_type`|可选：尾置返回类型，显式指定 Lambda 的返回值类型（省略则编译器自动推导）|
|`{ body }`|函数体：Lambda 要执行的逻辑|

### 1. 捕获子句（核心：捕获外部变量）

捕获子句决定 Lambda 能否访问外部变量、以何种方式访问（值 / 引用），是 Lambda 最灵活也最易踩坑的部分。

#### （1）基础捕获方式

|捕获语法|含义|示例|
|---|---|---|
|`[]`|无捕获：无法访问外部变量（可转函数指针）|`[]() { cout << "empty"; }`|
|`[x]`|值捕获：拷贝外部变量 `x` 到 Lambda 内部（只读，除非加 `mutable`）|`int x=5; [x]() { cout << x; }`|
|`[&x]`|引用捕获：引用外部变量 `x`（可修改，需注意变量生命周期）|`int x=5; [&x]() { x++; }`|
|`[=]`|隐式值捕获：拷贝所有外部变量到 Lambda 内部|`int x=5,y=6; [=]() { cout << x+y; }`|
|`[&]`|隐式引用捕获：引用所有外部变量|`int x=5,y=6; [&]() { x++; y++; }`|
|`[this]`|捕获当前类的 `this` 指针：可访问类的成员变量 / 成员函数（类内 Lambda）|`class A { int x; void f() { [this]() { x++; } } };`|
|`[=,&x]`|混合捕获：隐式值捕获所有变量，仅显式引用捕获 `x`|`int x=5,y=6; [=,&x]() { x++; cout << y; }`|

#### （2）进阶捕获（C++14+）

|捕获语法|含义|示例|
|---|---|---|
|`[x = 10]`|初始化捕获：在 Lambda 内部定义变量 `x` 并赋值（无需外部有 `x`）|`[x=10]() { cout << x; }`|
|`[ptr = std::move(obj)]`|移动捕获：将外部对象 `obj` 移动到 Lambda 内部（避免拷贝）|`string s="hello"; [ptr=move(s)]() { cout << ptr; }`|
|`[&x = y]`|引用初始化捕获：Lambda 内部的 `x` 引用外部变量 `y`|`int y=5; [&x=y]() { x++; }`|

#### （3）捕获的核心坑点
**引用捕获的生命周期问题**：若 Lambda 生命周期超过被引用变量的生命周期，会导致 “悬空引用”（访问已销毁的变量）：
```cpp
// 错误示例：引用捕获局部变量 s，返回后 s 销毁，Lambda 引用悬空
auto bad_lambda() {
    string s = "hello";
    return [&s]() { cout << s; }; // 危险！
}

int main() {
    auto f = bad_lambda();
    f(); // 未定义行为（s 已销毁）
    return 0;
}
```
**值捕获的不可修改性**：值捕获的变量默认是 `const`，需加 `mutable` 才能修改（修改的是拷贝，不影响外部变量）：
```cpp
int x = 5;
// 错误：值捕获的 x 是 const，无法修改
// [x]() { x++; } 

// 正确：加 mutable 后可修改拷贝（外部 x 仍为 5）
[x]() mutable { x++; cout << x; }(); // 输出 6
cout << x; // 输出 5
```
### mutable 关键字

- 仅影响**值捕获**的变量：解除值捕获变量的 `const` 限制（允许修改拷贝）；
- 不影响引用捕获（引用捕获本身可修改外部变量，无需 `mutable`）；
- ```cpp
int x = 5;
// mutable 允许修改值捕获的 x（拷贝）
[x]() mutable {
    x = 10;
    cout << "内部 x：" << x; // 10
}();
cout << "外部 x：" << x; // 5（外部无变化）
```
### noexcept 说明符

- 声明 Lambda 不会抛出异常，等价于普通函数的 `noexcept`；
- 若 Lambda 抛出异常但声明了 `noexcept`，程序会调用 `std::terminate` 终止；
- ```cpp
auto safe_lambda = []() noexcept {
    // 若此处抛异常，程序直接终止
    cout << "no exception";
};
```
## 三、Lambda 的类型与存储

### 1. 闭包类型的匿名性

Lambda 的类型是编译器生成的匿名类（如 `__lambda_12345`），无法显式声明，需通过以下方式存储：

- `auto`：推导 Lambda 的原始闭包类型（效率最高，无额外开销）；
- `std::function`：封装任意可调用对象（兼容有 / 无捕获 Lambda，有轻微封装开销）；
- 函数指针：仅支持无捕获 Lambda（隐式转换）。

示例：三种存储方式对比
```cpp
#include <functional>
using namespace std;

int main() {
    // 1. auto：存储原始闭包类型（推荐，无开销）
    auto lambda1 = [](int a) { return a + 1; };

    // 2. std::function：封装（兼容所有 Lambda）
    function<int(int)> f1 = lambda1;
    int x = 5;
    function<int(int)> f2 = [x](int a) { return a + x; }; // 有捕获也支持

    // 3. 函数指针：仅无捕获 Lambda 可用
    int (*fp)(int) = lambda1; // 隐式转换

    // 调用方式一致
    cout << lambda1(1) << endl; // 2
    cout << f1(1) << endl;      // 2
    cout << fp(1) << endl;      // 2
    return 0;
}
```
### 2. 无捕获 Lambda 转函数指针的规则

- 仅无捕获 Lambda 可隐式转换为匹配签名的函数指针；
- 模板推导时不会自动触发该转换（需显式转换或指定模板参数）
```cpp
template <typename Func>
void call(Func f) { f(10); }

int main() {
    auto lambda = [](int a) { cout << a; };
    // 报错：模板推导无法自动转换 Lambda 为函数指针
    // call(lambda);

    // 解决1：显式转换为函数指针
    call(static_cast<void(*)(int)>(lambda));

    // 解决2：指定模板参数为函数指针类型
    call<void(*)(int)>(lambda);
    return 0;
}
```
## Lambda 与其他可调用对象的对比

|可调用对象|优点|缺点|适用场景|
|---|---|---|---|
|普通函数|类型明确，无额外开销|无法捕获外部变量，需单独定义|通用、复用性高的逻辑|
|函数指针|轻量，兼容 C 代码|无法捕获外部变量，类型固定|C 接口回调、简单无状态逻辑|
|伪函数（函数对象）|可存储状态，编译期优化好|代码繁琐，需单独定义类|复杂有状态逻辑、高性能场景|
|Lambda 表达式|简洁、就地定义、支持捕获|类型匿名，有捕获时无法转函数指针|临时、短小、带状态的逻辑|
|std::function|统一封装所有可调用对象|有轻微封装开销，运行时多态|需存储 / 传递任意可调用对象|

