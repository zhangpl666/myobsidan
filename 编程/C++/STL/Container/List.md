# std::List 链表
在 C++ STL 中，`std::list` 是一个**双向链表（Doubly Linked List）**。与 `std::vector`（动态数组）不同，`list` 在内存中并不是连续存储的，而是通过指针将一个个独立的节点连接起来。

---

## 1. 核心结构

每个节点包含三个部分：

- **数据域**：存储实际的元素值。
    
- **前驱指针 (`prev`)**：指向前一个节点。
    
- **后继指针 (`next`)**：指向后一个节点。
    

---

## 2. list 的优缺点

### ✅ 优点

1. **高效插入和删除**：在已知迭代器位置的情况下，插入或删除元素的时间复杂度为 $O(1)$。只需要改变指针的指向，不需要移动其他元素。
    
2. **任意位置操作**：由于是双向的，在头部、中间或尾部插入/删除都非常快。
    
3. **迭代器稳定性**：除非你删除了某个节点，否则指向该节点的迭代器在添加或删除其他元素时**始终有效**。而 `vector` 在扩容时会导致所有迭代器失效。
    

### ❌ 缺点

1. **不支持随机访问**：你不能通过索引（如 `list[5]`）直接访问元素。要找到第 $n$ 个元素，必须从头或从尾开始遍历，时间复杂度为 $O(n)$。
    
2. **内存开销大**：每个元素都需要额外存储两个指针（`prev` 和 `next`），对于存储小型数据（如 `int`）来说，空间利用率较低。
    
3. **缓存不友好**：由于节点散落在内存各处，无法利用 CPU 缓存的局部性原理，遍历速度通常慢于 `vector`。
    

---

## 3. 常用操作

`list` 提供了专门针对链表优化的成员函数：

|**操作**|**函数**|**说明**|
|---|---|---|
|**头部/尾部访问**|`push_front()` / `push_back()`|在两端添加元素，$O(1)$|
|**删除**|`pop_front()` / `pop_back()`|删除两端元素，$O(1)$|
|**插入/擦除**|`insert()` / `erase()`|在迭代器指定位置操作，$O(1)$|
|**特殊操作**|`sort()`|**注意**：必须使用 `list.sort()` 而非 `std::sort()`|
|**合并/去重**|`merge()` / `unique()`|合并两个已序链表或删除连续重复元素|
|**反转**|`reverse()`|原地反转链表顺序|

---

## 4. 特别注意：list 为什么有自己的 sort？

这是一个面试高频考点。

std::sort 算法要求容器支持随机访问迭代器（Random Access Iterators），但 list 只提供双向迭代器（Bidirectional Iterators）。因此，list 内部实现了一个专门的 sort 成员函数（通常基于归并排序）。

C++

```
#include <list>
#include <algorithm>

std::list<int> myList = {3, 1, 4};

// std::sort(myList.begin(), myList.end()); // ❌ 编译错误！
myList.sort();                             // ✅ 正确做法
```

---

## 5. 什么时候该用 list？

- 你需要在容器**中间频繁地插入或删除**元素。
    
- 你不需要通过索引访问元素。
    
- 你需要保证在添加元素后，原本指向其他元素的迭代器依然有效。
    

**对比建议：** 如果你主要是在末尾添加数据并经常需要查找，请无脑选 `std::vector`；如果你的应用场景符合上述“频繁中段操作”，再考虑 `std::list`。
