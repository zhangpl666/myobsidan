
学习迭代器，最有效的方法不是看定义，而是**模拟它的进化过程**。让我们换个思路，从“为什么要发明这玩意儿”开始，一步步带你写代码理解。

---

## 为什么不能只用索引（Index）？

```cpp
// 场景 1：数组/vector
int arr[] = {1, 2, 3};
for(int i = 0; i < 3; ++i) cout << arr[i]; // 没问题，下标访问很快

// 场景 2：链表/list
// 链表节点是散落在内存里的。如果你用下标 list[5]，
// 计算机必须从第 1 个节点开始，数 5 次指针才能找到。
// 如果你在循环里写 list[i]，每一步都要从头数，时间复杂度会爆炸成 O(n²)！
```

**结论：** 我们需要一种“不依赖下标”的通用方式，能让计算机**“记住当前在哪，直接找下一个”**。

---

## 迭代器——一个“伪装成指针”的盒子

你可以把迭代器想象成一个包裹着指针的**小盒子**。为了让你用起来舒服，C++ 对这个盒子做了**运算符重载**。

- **`*it`**：盒子说：“虽然我是个对象，但你用 `*` 我时，我会把盒子里存的那个数据给你。”
    
- **`++it`**：盒子说：“当你对我加 1 时，我会根据容器的规则（是挪地址还是找下一个指针），帮你移动到下一个元素。”
    

### 动手写：最简单的迭代器用法

不要去看底层源码，先看最标准的写法：

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> v = {10, 20, 30};

    // 1. 获取起点的盒子 (begin) 和 终点之后的盒子 (end)
    std::vector<int>::iterator it = v.begin(); 
    
    // 2. 循环判断：只要盒子还没到终点，就继续
    while (it != v.end()) {
        std::cout << *it << " "; // 3. 像指针一样解引用取值
        ++it;                   // 4. 像指针一样自增移动
    }
}
```

---

## 迭代器最核心的“坑”——前闭后开 `[begin, end)`

这是新手最容易犯错的地方。请看下图：

```explain
元素：  [ 10 ]  [ 20 ]  [ 30 ]  [ ??? ]
位置：    ↑                       ↑
        begin()                 end()
```

- **`begin()`**：指向第一个元素（10）。
    
- **`end()`**：指向**最后一个元素的后面**。那里什么都没有，是一个虚拟的“墙壁”。
    

为什么不直接指向 30？

因为如果容器是空的，begin 和 end 都会指向这堵“墙”。这样我们写 while(it != end()) 时，循环一次都不会执行。这叫算法的优雅性。

---

## 进阶——迭代器失效

这是新手在写 `erase`（删除）时最常崩溃的地方:

```cpp
for (auto it = v.begin(); it != v.end(); ++it) {
    if (*it == 20) {
        v.erase(it); // ❌ 大错特错！
    }
}
```

为什么错？

当你把 20 删掉后，后面的元素会整体往前挪。此时你手里的 it 已经变成了一个“丧尸指针”，它指向的内存已经乱了。紧接着 for 循环还要执行 ++it，程序直接崩溃（Crash）。

正确写法：

erase 函数会返回一个新的、有效的迭代器，指向被删元素的下一个。

```cpp
for (auto it = v.begin(); it != v.end(); ) { // 注意这里不写 ++it
    if (*it == 20) {
        it = v.erase(it); // 更新盒子，接住返回的“新位置”
    } else {
        ++it; // 没删除时才手动移动
    }
}
```

---

下一篇：[[Iterator分类]]


---

