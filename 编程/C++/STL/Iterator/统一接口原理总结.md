这里我们谈一下access统一接口的原理
# 一、tag dispatch(before C++11/C++14)
## 1️⃣tags标签
每一种迭代器都会有一个标签：
- Input iterator : `input_iterator_tag`
- Forward iterator : `forward_iterator_tag`
- Bidirectional iterator : `bidirectional_iterator_tag`
- Random access iterator : `random_access_iterator_tag`
他们功能递进，tag的本质就是继承：
```cpp
struct input_iterator_tag{};
struct forward_iterator_tag : input_iterator_tag{};
struct bidirectional_iterator_tag : forward_iterator_tag{};
struct random_access_iterator_tag : bidirectional_iterator_tag{};
```
虽然都是空类，但起到标签作用
这些tag统一被`using`为`iterator_category`以实现跟iterator_traits的链接
## 2️⃣iterator_traits<>
iterator_traits用于拿到合法标签，进而调用正确的函数接口
其本质是模板结构体：
```cpp
template<typename It>
struct iterator_traits{
	using iterator_category = typename It::iterator_category
}
//由于指针就是随机访问迭代器，所以要加一个偏特化模板
template<typename It>
struct iterator_traits<It*>{
	using iterator_category = std::random_access_iterator_tag;
}
```
写的时候就是：
```cpp
iterator_category<it>//这里还只是一个类
iterator_category<it>::iterator_category//这里就是把里面的类型名取出来
```

## 3️⃣针对不同迭代器的重载函数
 ```cpp
 template<typename T>//for input and forward
//这里的函数参数类型是包含类型名的
//WARNING：记得传入的是引用，不然不能真实修改值
    void advance_impl(T& it, int n, std::input_iterator_tag){

        while(n--){

            it++;

        }

    }

    template<typename T>//for bidirectional 

    void advance_impl(T& it, int n, std::bidirectional_iterator_tag){

        if(n>0)while(n--)it++;

        else while(n++)it--;

    }

  

    template<typename T>//for random access

    void advance_impl(T& it, int n,std::random_access_iterator_tag){

        it+=n;

    }
    ```

## 4️⃣统一接口：
最后实现统一函数接口：
```cpp
template<T>
void advance(T& it, int n){
	advance_impl(it,n, iterator_traits<it>::iterator_category);
}
```

# 二、if constexpr(C++17)