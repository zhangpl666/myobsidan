#### 1. `static_cast`：编译期的 “安全基础转换”
- **适用场景**：
    - 基础类型转换（如 `int → double`、`char → int`）；
    - 类的**向上转型**（子类指针 / 引用 → 基类指针 / 引用，安全）；
    - 类的**向下转型**（基类指针 / 引用 → 子类指针 / 引用，_编译期不检查类型，需程序员保证安全_）；
    - 空指针 / 空引用转换（如 `void* → 其他类型指针`）。
跟C语言的没什么区别，没有额外性能开销
- **特点**：编译期完成，无运行时开销；比 C 风格转换更安全，但向下转型时仍有风险。


#### 2. `dynamic_cast`：运行时的 “类型安全转换”

- **适用场景**：
    仅用于**带虚函数的类**的**指针 / 引用转换**（依赖 RTTI 运行时类型信息），主要用于**向下转型**（基类 → 子类）。
- **特点**：
    - 运行时检查类型，转换失败时：指针返回 `nullptr`，引用抛出 `std::bad_cast` 异常；
    - 有运行时开销（比 `static_cast` 慢），但安全性最高；
    - 仅支持 “带虚函数的类”（否则编译报错）。

#### 3. `const_cast`：“移除 const/volatile 属性” 的专用转换

- **适用场景**：
    
    仅用于**移除变量的`const`或`volatile`限定符**（不能改变类型）。
- **特点**：
    - 只能修改 “const 属性”，不能转换类型；
    - 谨慎使用：修改原`const`变量会导致**未定义行为**（UB）。
```cpp
合法场景：函数参数需要非const，但实际不修改内容
```

#### 4. `reinterpret_cast`：“暴力类型重解释”

- **适用场景**：
    
    最底层的二进制转换，将一种类型**按字节直接解释为另一种类型**（仅用于特殊场景）。
- **特点**：
    - 完全不做类型检查，仅按字节重解释；
    - 极度危险，仅用于底层硬件 / 二进制协议等特殊场景；
    - 不可移植（不同编译器 / 平台的二进制布局可能不同）。


这其中只有dynamic_cast最安全
除了dynamic_cast ，别的类型转换没有额外开销
但dynamic_cast的开销是真的很大