在 C/C++ 中，**预处理（Preprocessing）** 是编译过程的第一个阶段，由**预处理器（Preprocessor）** 完成。它的核心作用是：在编译器真正编译代码之前，对源代码进行文本级别的替换、宏展开、条件编译等操作，最终生成一份 “纯净” 的、可直接编译的代码（通常以 `.i` 为后缀的中间文件）。

预处理的特点是：**不理解 C/C++ 语法**（只做文本替换）、**无类型检查**、**操作结果不可逆**（替换后原代码结构被改变）。

## 一、预处理的核心作用

1. **文本替换**：将宏定义、头文件内容替换到源代码中。
2. **条件编译**：根据条件决定哪些代码保留、哪些代码丢弃（用于跨平台、调试等场景）。
3. **文件包含**：将头文件（`.h`）的内容嵌入到 `#include` 所在位置。
4. **特殊操作**：如 #line 调整行号、#error 触发编译错误等。

## 二、预处理指令（关键语法）

预处理指令以 `#` 开头，且必须独占一行（`#` 前可加空格，后可加注释），常用指令如下：

### 1. 文件包含：`#include`（最常用）

作用：将指定文件的内容**原封不动嵌入**到当前 `#include` 所在位置，解决代码复用（如函数声明、宏定义、结构体定义）。

#### 两种语法格式

|格式|查找路径|适用场景|
|---|---|---|
|`#include <文件名>`|优先从**系统标准库路径**查找（如 `/usr/include`、VS 的安装目录）|包含系统头文件（如 `<stdio.h>`、`<vector>`）|
|`#include "文件名"`|优先从**当前源文件所在目录**查找，找不到再去系统路径查找|包含自定义头文件（如 `myfunc.h`）|

#### 注意事项

- 避免头文件重复包含：多次 `#include` 同一个头文件会导致代码冗余（如结构体重复定义、函数重声明），需用 “头文件保护”（下文会讲）。
- 不包含 `.cpp` 文件：`.cpp` 是源文件（含实现），包含后可能导致重复编译（链接时符号重定义错误）。

### 2. 宏定义：`#define`（文本替换）

作用：定义一个 “宏”，预处理时将代码中所有宏名替换为指定文本（无类型检查，纯文本替换）。

#### （1）无参数宏（常量定义）

c

```c
#define PI 3.1415926  // 定义常量宏
#define MAX(a, b) ((a) > (b) ? (a) : (b))  // 带参数宏（注意括号！）
#define PRINT printf("Hello, Preprocess!\n")  // 代码片段宏
```

#### （2）带参数宏（类似函数，但不是函数）

- 优势：无函数调用开销（直接替换），支持任意类型（无需模板）。
- 坑点：必须加足够括号，避免运算符优先级问题：
    
    c
    
    ```c
    // 错误写法（无括号）
    #define MUL(a, b) a * b
    int x = MUL(2 + 3, 4);  // 替换后是 2+3*4 = 14（预期是 5*4=20）
    
    // 正确写法（加括号）
    #define MUL(a, b) ((a) * (b))
    int x = MUL(2 + 3, 4);  // 替换后是 ((2+3)*4) = 20
    ```
    

#### （3）取消宏定义：`#undef`

c

```c
#define NUM 100
printf("%d\n", NUM);  // 替换为 100
#undef NUM  // 取消 NUM 的宏定义
printf("%d\n", NUM);  // 编译错误（NUM 未定义）
```

### 3. 条件编译：`#if`/`#ifdef`/`#ifndef`/`#else`/`#elif`/`#endif`

作用：根据条件决定是否保留某段代码（预处理时直接丢弃不满足条件的代码），常用于：

- 跨平台适配（如 Windows/Linux 不同 API）；
- 调试模式开关（如打印调试日志）；
- 避免头文件重复包含。

#### 常用场景

##### （1）调试模式开关

c

```c
#define DEBUG 1  // 1 开启调试，0 关闭

int main() {
    int x = 10;
    #if DEBUG
        printf("调试：x = %d\n", x);  // DEBUG=1 时保留，=0 时丢弃
    #endif
    return 0;
}
```

##### （2）跨平台适配

c

```c
#ifdef _WIN32  // Windows 系统宏（VS 定义）
    #include <windows.h>
    void func() { /* Windows 特有 API */ }
#elif __linux__  // Linux 系统宏（GCC 定义）
    #include <unistd.h>
    void func() { /* Linux 特有 API */ }
#else
    #error "不支持的操作系统"  // 触发编译错误
#endif
```

##### （3）头文件保护（关键！）

解决 “头文件重复包含” 问题（如 `a.h` 包含 `b.h`，`main.cpp` 同时包含 `a.h` 和 `b.h`，会导致 `b.h` 内容重复）：

c

```c
// myfunc.h（自定义头文件）
#ifndef MYFUNC_H  // 如果 MYFUNC_H 未定义
#define MYFUNC_H  // 定义 MYFUNC_H

// 头文件内容（函数声明、结构体定义等）
void add(int a, int b);
struct Person { int age; };

#endif  // 结束条件编译
```

- 第一次 `#include "myfunc.h"`：`MYFUNC_H` 未定义，执行 `#define MYFUNC_H` 并保留后续代码；
- 第二次 `#include "myfunc.h"`：`MYFUNC_H` 已定义，直接跳过后续代码，避免重复。

### 4. 其他常用指令

- `#error "错误信息"`：预处理时触发编译错误，强制停止编译（如上述跨平台适配中 “不支持的系统”）。
- `#warning "警告信息"`：预处理时输出警告，不停止编译（提醒开发者注意）。
- `#line 行号 "文件名"`：修改当前代码的行号和文件名（用于编译器报错时显示自定义位置，少见）。
- `#pragma`：编译器指令（不同编译器支持不同），如：
    
    c
    
    ```c
    #pragma once  // 替代头文件保护（GCC/VS 都支持），作用：当前头文件只包含一次
    #pragma warning(disable:4996)  // VS 中禁用 4996 警告（如 scanf 不安全警告）
    ```
    

## 三、预处理的执行顺序

预处理是按**源代码从上到下**顺序执行的，指令之间有依赖关系：

1. 先处理 `#include`：将头文件内容嵌入，再处理嵌入后的代码；
2. 再处理 `#define`/`#undef`：宏定义和取消；
3. 然后处理条件编译：`#if`/`#ifdef` 等，丢弃不满足条件的代码；
4. 最后进行宏替换：将所有宏名替换为指定文本。

示例：

c

```c
#include <stdio.h>  // 1. 先嵌入 stdio.h 内容
#define DEBUG 1     // 2. 定义 DEBUG 宏

int main() {
    #if DEBUG       // 3. 条件编译（DEBUG=1，保留后续代码）
        PRINT;      // 4. 宏替换为 printf("Hello...\n")
    #endif
    return 0;
}
```

## 四、预处理的常见坑点

1. **宏替换无类型检查**：
    
    c
    
    ```c
    #define NUM 100
    int x = NUM + 3.14;  // 预处理后是 100 + 3.14，编译时才检查类型（int 与 double 相加）
    ```
    
2. **带参数宏的副作用**：
    
    c
    
    ```c
    #define MAX(a, b) ((a) > (b) ? (a) : (b))
    int x = 1, y = 3;
    int res = MAX(x++, y++);  // 替换后是 ((x++) > (y++) ? (x++) : (y++))
    // 执行过程：x=1 > y=3？否 → 执行 y++ → y 变成 4，res=3；最终 x=2，y=4（非预期）
    ```
    
    解决：宏参数尽量用纯变量，或用 `inline` 函数替代（C++）。
    
3. **头文件保护必须加**：忘记加 `#ifndef`/`#define`/`#endif` 会导致重复定义错误（如结构体、函数重声明）。
    
4. **宏定义末尾不要加 `;`**：
    
    c
    
    ```c
    #define PI 3.14;  // 错误：多了 ;
    double area = PI * r * r;  // 替换后是 3.14; * r * r → 语法错误
    ```
    
5. **`#pragma once` 与头文件保护的区别**：
    
    - `#pragma once` 是编译器扩展，简单高效，但不支持跨编译器（极少数老编译器不支持）；
    - `#ifndef` 是标准语法，兼容性好，适用于所有编译器，推荐优先使用。

## 五、如何查看预处理结果（调试用）

如果想知道预处理后代码变成了什么样子，可以用编译器生成中间文件：

- GCC/G++：`g++ -E test.cpp -o test.i`（`-E` 表示只执行预处理，不编译）；
- VS：在项目属性中开启 “生成预处理文件”，编译后会生成 `.i` 文件。

打开 `test.i` 文件，可以看到：

- `#include <stdio.h>` 被替换为 stdio.h 的所有内容；
- 宏定义被完全替换；
- 条件编译中不满足的代码被删除。

## 总结

预处理是 C/C++ 编译的 “前置操作”，核心是**文本级替换和条件筛选**，关键用途：

1. 用 `#include` 复用头文件；
2. 用 `#define` 定义常量 / 代码片段；
3. 用条件编译实现跨平台 / 调试开关；
4. 用头文件保护避免重复包含。

掌握预处理的核心是：理解 “文本替换” 的本质，避开宏定义的副作用，规范使用条件编译和头文件保护。