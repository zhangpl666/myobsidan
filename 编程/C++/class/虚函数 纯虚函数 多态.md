# 虚函数
由于子类是也是父类的一种，于是子类指针可以赋值给父类指针变量
但当该指针调用子和父拥有的同名函数时，真正调用的是父的函数，而我们期望调用的是子的那个函数

当有许多对象的时候，大家有统一的行为名但实现方法不同，是否要给不同对象分别取名？

## 虚函数与覆写
父与子有同名函数且都给出实现时

父类的同名函数可以加上virtual标签，子类同名函数加上override标签。当子类指针赋值给父类指针变量时，调用函数会给出子函数的实现
这里就是子函数的覆写。
若子类中没有同名函数，则实现父类中的函数（基类）
这使得代码可读性更好，更整洁

```cpp
#include <iostream>
using namespace std;

// 基类：所有电子产品的统称
class ElectronicProduct {
public:
    // 虚函数：统一接口“开机”，有默认实现
    virtual void powerOn() {
        cout << "电子产品默认开机方式：按电源键\n";
    }
};

// 子类1：手机（重写开机方式）
class Phone : public ElectronicProduct {
public:
    void powerOn() override { // override 明确表示重写基类虚函数（可选但推荐）
        cout << "手机开机：短按侧边电源键\n";
    }
};

// 子类2：电脑（重写开机方式）
class Computer : public ElectronicProduct {
public:
    void powerOn() override {
        cout << "电脑开机：按主机正面开机键\n";
    }
};

// 子类3：普通音箱（不重写，用默认实现）
class Speaker : public ElectronicProduct {
    // 没有重写powerOn，继承基类的默认实现
};

int main() {
    // 关键：基类指针/引用指向子类对象，调用的是子类的实现（多态）
    ElectronicProduct* p1 = new Phone();
    ElectronicProduct* p2 = new Computer();
    ElectronicProduct* p3 = new Speaker();

    p1->powerOn(); // 输出：手机开机：短按侧边电源键（子类实现）
    p2->powerOn(); // 输出：电脑开机：按主机正面开机键（子类实现）
    p3->powerOn(); // 输出：电子产品默认开机方式：按电源键（基类默认实现）

    delete p1; delete p2; delete p3;
    return 0;
}
```

## 底层工作原理
虚函数、静态函数和非静态函数都单独储存在代码段中，所有该类的实体共享一份，不占用类的内存

不同的是，虚函数不是编译期函数，为了实现多态的功能，虚函数需要运行时动态绑定。在构造函数执行时，初始化了一个vptr虚函数指针（对象级），每一个实体会保存一个vptr以找到这个类共享的vtable虚函数表。所以此时sizeof就会发现内存大于设想

普通成员函数依赖[[This指针]]，[[静态#static函数||静态函数]]编译时就已经确定，不需要绑定对象

**占用内存的时指针而不是虚函数，一个实体只会保存一个vptr，跟有几个虚函数无关**


# 纯虚函数
当一个基类中有虚函数且形式为：virtual 返回值 函数名（） = 0 ，没有给出实现，，则这些函数为纯虚函数，这个父（基）类叫抽象类，不能实例化，在C#和Java中又叫接口
纯虚函数强制要求子类给出实现，否则该子类不能使用，变成抽象类
```cpp
#include <iostream>
using namespace std;

// 抽象类：智能设备（包含纯虚函数，不能实例化）
class SmartDevice {
public:
    // 纯虚函数：统一接口“联网”，无默认实现，强制子类重写
    virtual void connectNetwork() = 0;

    // 普通虚函数：可以有默认实现（比如“开机”）
    virtual void powerOn() {
        cout << "智能设备默认开机：按电源键\n";
    }
};

// 子类1：智能手机（必须重写connectNetwork）
class SmartPhone : public SmartDevice {
public:
    void connectNetwork() override {
        cout << "手机联网：连接4G/5G或WiFi\n";
    }

    // 可选重写powerOn
    void powerOn() override {
        cout << "智能手机开机：短按侧边电源键（带指纹解锁）\n";
    }
};

// 子类2：平板电脑（必须重写connectNetwork）
class Tablet : public SmartDevice {
public:
    void connectNetwork() override {
        cout << "平板联网：连接WiFi（部分支持5G）\n";
    }
};

// 错误示例：如果子类不重写纯虚函数，就是抽象类，不能实例化
// class BadDevice : public SmartDevice {
//     // 没有重写connectNetwork
// };

int main() {
    // 错误：抽象类不能实例化
    // SmartDevice* p = new SmartDevice();

    // 正确：基类指针指向子类对象（多态）
    SmartDevice* p1 = new SmartPhone();
    SmartDevice* p2 = new Tablet();

    p1->powerOn();        // 输出：智能手机开机：短按侧边电源键（带指纹解锁）
    p1->connectNetwork(); // 输出：手机联网：连接4G/5G或WiFi
    p2->powerOn();        // 输出：智能设备默认开机：按电源键（基类默认）
    p2->connectNetwork(); // 输出：平板联网：连接WiFi（部分支持5G）

    delete p1; delete p2;
    return 0;
}
```

# 多态
**“同一接口，不同表现”**
**有一个统一的 “动作名称”（接口），但不同 “对象” 执行时，会根据自身特性给出不同的 “结果 / 流程”（实现）**—— 这就是多态的本质，编程中的多态，就是把这种生活逻辑映射到代码里。
参考上面给的代码示例，应该有所感悟。