# 什么是构造函数和析构函数

当你自定义变量（class or struct）的时候，也许会写：
```cpp
class name{
public:
	int X, Y;
}
int main(){
	name a;
	a.X = 0;
	a.Y = 0;
}
```
在这个过程中构造了一个name类型的a，而这个过程就是调用了name里的构造函数；
哪有构造函数？我怎么没看到？
你不写->程序默认一个啥也不干的构造函数
构造函数无需类型，函数名必须是class类型名
```cpp
class name{
public:
	int X, Y;
	name(){}//若你也什么都不写，至少会初始化里面的变量为0
}
```
小括号为输入，大括号为操作，和一般函数差不多。
当然你也可以有不止一个构造函数，具体调用哪个取决于你构造的时候怎么写
```cpp
class name{
public:
	int X, Y;
	name(int a, int b){X = a;Y = b;}
}
int main(){
	name a(3,4);
}
```

## 析构函数：
就是和构造函数反着来，函数名前面加~就行

**只有析构函数有虚析构，构造函数是没有虚函数的！！**
因为虚函数是在实体初始化以后才生成的虚函数表
意味着构造子类的时候基类的构造函数和自身的都会调用
# 成员初始化列表
在初始化的时候，你可以选择在构造函数里写初始化的值，但这样会初始化两次，造成性能的浪费
```cpp
class Entity{
private:
	int X, Y;
public:
	Entity(){
		X = 1;
		Y = 2;
	}
}
```
## 为什么会初始化两次？
类成员的初始化优先级最高 —— 在构造函数体执行前，所有成员会先调用自己的**默认构造函数**完成初始化。

上面的例子中，由于class可以直接调用自己的变量，所以当你在构造函数中写X的时候就已经初始化了一个变量了。X=1实际是赋值操作，将最开始初始化的值覆写了

## 成员初始化列表
用这种方式初始化，系统自动带参初始化：
在构造函数后，大括号前，打冒号，后面跟参数，括号内是初始化值
值得注意的是，最好按顺序写
```cpp
class Entity{
private:
	int X, Y;
	std::string Name;
public:
	Entity()
		:X(1),Y(2),Name("penglai")
	{
	}
}
```

### 这些情况必须用初始化列表（否则编译失败 / 行为异常）

手动赋值不仅有重复开销，某些场景下根本无法使用，只能用初始化列表：

-  **const 成员变量**：const 变量必须在初始化时赋值，不能先默认初始化再赋值（编译报错）；
```cpp
#include <iostream>
using namespace std;

class Test {
private:
    const int a; // const 成员，必须初始化时赋值
public:
    // 手动赋值：编译报错
    Test() 
	    :a(10)//正确
    {
        //a = 10; // 错误：const 变量不能默认初始化后再赋值
    }
};

int main() {
    Test t;
    return 0;
}
```
**报错信息**（不同编译器类似）：

`error: assignment of read-only member 'Test::a'`

（只读成员无法赋值）

-  **引用成员变量**：引用必须绑定到对象，无法默认初始化后再赋值（编译报错）；
```cpp
#include <iostream>
using namespace std;

class Test {
private:
    int& b; // 引用成员，必须绑定对象
public:
    // 手动赋值：编译报错
      Test(int x) 
	    :b(x)//正确
    {
       // b = x; // 错误：引用未初始化，且不能后绑定
    }
};

int main() {
    int num = 20;
    Test t(num);
    return 0;
}
```
**报错信息**：

`error: uninitialized reference member 'Test::b'`

（未初始化的引用成员）

-  **没有默认构造函数的成员**：如果成员类只有带参构造（无默认构造），编译器无法自动默认初始化，必须在初始化列表中传参构造；
```cpp
#include <iostream>
using namespace std;

// 成员类：只有带参构造，无默认构造（默认构造被显式删除）
class MyMember {
public:
    MyMember(int val) { // 仅带参构造
        cout << "MyMember 带参构造: " << val << endl;
    }
    // 注意：如果不写默认构造，且写了带参构造，编译器不会生成默认构造
};

class Test {
private:
    MyMember m; // 成员是MyMember，无默认构造
public:
    // 手动赋值：编译报错
    Test() 
	    :m(30)//正确
    {
        //m = MyMember(30); // 错误：m需要先默认构造， but MyMember没有默认构造
    }
};

int main() {
    Test t;
    return 0;
}
```
**报错信息**：

`error: no matching function for call to 'MyMember::MyMember()'`

（没有匹配的默认构造函数可调用）

-  **继承场景**：子类初始化父类（尤其是父类无默认构造时），必须在初始化列表中调用父类带参构造。
```cpp
#include <iostream>
using namespace std;

// 父类：只有带参构造，无默认构造
class Parent {
public:
    Parent(int val) {
        cout << "Parent 带参构造: " << val << endl;
    }
};

// 子类继承父类
class Child : public Parent {
public:
    // 手动赋值：编译报错
    Child()
	    :Parent(40)//正确
    {
        // 错误：父类Parent无默认构造，无法自动初始化，且不能在这里手动赋值父类
    }
};

int main() {
    Child c;
    return 0;
}
```
**报错信息**：

`error: no matching function for call to 'Parent::Parent()'`

（父类没有默认构造，无法自动初始化）
# 拷贝构造函数
当我们拷贝一个类的实体的时候，系统会调用拷贝构造函数（不写就是调用默认的）拷贝构造函数大致跟构造函数差不多，只不过在拷贝的时候调用而已
形式：`class名（const class名* 源对象）{}
```cpp
class String{
private:
	char* Buffer;
	unsigned int Len;
public:
	//构造函数
	String(const char* string)
	{
	Len = strlen(string);
	Buffer = new char[len+1];
	memcpy(Buffer,string,len);
	}	
	//拷贝构造函数 ，这里写的内容跟默认的没区别
	String(const String& other){
	Len = other.Len;
	Buffer = other.Buffer;
	}
	~String(){
		delete[] Buffer;
	}
}
```

默认的拷贝构造函数会将class中的所有成员变量复制。如果有指针，那么拷贝的是指针而不是指向的内容，即两个指针指向同一块内存

出现问题！如果用new申请的内存，在这个类的实体析构的时候会释放内存，这样同一块内存就会多次释放，程序报错

## 深拷贝
就是在拷贝时将指针指向的内存一起拷贝一份，这样在析构的时候就不会将一块内存同时释放了
```cpp
String(const String* other){
	Len = other.Len;
	Buffer = new char[Len+1];
	memcpy(Buffer,other.Buffer,Len+1)
}
```
## 禁用拷贝函数
```cpp
String(const String* other) = delete;
```
这样写就禁止拷贝构造，下面这种写法就不合法了
```cpp
String a(penglai);
//String b = a//拷贝构造，不合法
```