# 指针 & 函数
1. 指针函数
	1. 核心：本质是函数，返回值是指针
	2. “（）”优先级高于*
	 ```c
返回类型* 函数名(参数列表);

// 定义一个返回int*的函数（指针函数）
int* create_array(int size) {
    return (int*)malloc(size * sizeof(int)); // 返回动态分配的数组指针
}
```


2. 函数指针
	1. 核心本质是指针变量
	2. 专门用来指向函数（存储函数的入口地址）
	3. 存储函数地址，调用函数
	4. 函数指针的参数列表和返回类型必须与其指向函数完全一致
```c
返回类型 (*指针名)(参数列表);

int add(int a, int b) {
    return a + b;
}


    // 定义函数指针p，指向返回int、参数为(int,int)的函数
    int (*p)(int, int); 
    p = add; // 函数名即地址，赋值给函数指针

    // 通过函数指针调用函数（两种方式等价）
	printf("%d\n", p(2, 3));   // 输出5
    printf("%d\n", (*p)(2, 3)); // 输出5
```
是不是感觉函数指针没什么用？看看豆包怎么说[[函数指针的意义]]

# 指针 & 数组

1. 指针数组
	1. 核心：本质是数组，数组中每个元素是指针
	2. ”[]“优先级高于*
	3. 占用内存大小=数组长度乘以单个指针大小（64位系统中每个指针8字节）
```c
元素类型* 数组名[数组大小];

// 指针数组：存储5个int*指针的数组
int* ptr_arr[5]; 

// 常见用途：存储字符串（每个元素是char*指针）
char* strs[] = {"apple", "banana", "cherry"}; 
// strs是数组，strs[0]是指向"apple"的char*指针
```

2. 数组指针
	1. 核心：本质是指针变量
	2. 数组名只是第一个元素的地址，数组指针指向整个数组地址
	3. 类型是“元素类型【数组大小】”

```c
元素类型 (*指针名)[数组大小];



int arr[5] = {1,2,3,4,5};

// 定义数组指针p，指向“包含5个int的数组”
int (*p)[5]; 
p = &arr; // 取整个数组的地址（注意：arr是首元素地址，&arr是数组地址，类型不同）

// 访问数组元素：通过数组指针解引用后得到数组，再取下标
printf("%d\n", (*p)[0]); // 输出1（*p等价于arr
```


# 常量 & 指针

1. 指针常量
	1. 核心：本质是常量，类型是指针类型
	2. 指针的指向不能改，但指向的内容可以改
	3. const修饰的是指针名，所以指针的值（即地址）不能修改

```c
元素类型* const 指针名 = 初始地址;

int a = 10, b = 20;
int* const p = &a; // p是指针常量，指向a的地址（初始化后不能改指向）

*p = 30; // 允许：修改指向的内容（a变为30）
p = &b;  // 错误：指针常量的指向不能改
```

2. 常量指针
	1. 核心：本质是指针
	2. 指向的内容是常量不能改，但指针本身可以指向不同变量，也就是说可以修改

```c
const 元素类型* 指针名; 
// 或 元素类型 const* 指针名;（两种写法等价）

int a = 10, b = 20;
const int* p = &a; // p是常量指针，指向的内容（a）被视为常量

*p = 30; // 错误：不能修改指向的内容
p = &b;  // 允许：指针可以改指向（现在指向b）
```

3. 常量数组
	1. 核心：本质是数组
	2. 数组中的元素是常量，一旦初始化不可更改

```c
const 元素类型 数组名[数组大小] = {初始化值};
```


4. 指针常量指针
	1. 既不能改指向，也不能修改指向的内容
```c
数组类型* const* 指针名
```

5. 指向常量指针的指针常量
```c
int* const* const ptr
```

cpp中还有别的用法，可以去[[Const||这里看看]]
