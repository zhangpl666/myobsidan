# 引用介绍
引用的符号是&，跟指针形式一样的定义方法
（我认为跟指针一样理解成一种数据类型也没什么问题）

引用像是一个const，**在定义的时候就必须赋值 ，且不能修改**
这里&与取地址符不同，但本质都是取地址，*跟指针工作原理相同*，这意味将引用着传入给函数可以实现**真实修改**
但是，我们在赋值和使用的时候，不需要加取地址符和解引用这种，直接把他当一个普通数据类型用即可

引用可以理解**为为另一个变量取别名**，这个别名一直跟这个变量走

```c
void Set(int& b, int c){
	b = c;
	std::cout<< b <<std::cin;
}

int main(){
	int a;
	a = 4;
	int& b = a;//给a取别名，b不能再改为别的变量的别名
	b = 5;//这里本质就是将a改为五
	Set(b,6);//这里a被改成了6
}
```

# 引用与指针的核心区别

|**维度**|**引用（Reference）**|**指针（Pointer）**|
|---|---|---|
|**初始化**|必须在定义时初始化，且一旦初始化不能改变绑定目标|可以定义后再赋值，可指向不同变量或`NULL`/`nullptr`|
|**空值**|不存在 “空引用”，初始化时必须绑定有效变量|允许指向`NULL`/`nullptr`（空指针）|
|**语法复杂度**|使用时无需解引用（`*`）、取地址（`&`），像普通变量|需显式解引用（`*p`）、取地址（`&a`）操作|
|**底层实现**|多数编译器以指针实现，但语法上无感知|直接操作地址，语法上需明确处理地址|
|**sizeof**|与绑定变量的类型大小一致（本质是别名）|存储地址，大小为指针本身的字节数（如 64 位系统占 8 字节）|
这里关于引用、指针和sizeof还有一个[[引用#地址开销||魔鬼细节]]
## 函数传参中的引用、指针与`const`修饰

#### 1. 传引用（`pass by reference`）

- **普通引用传参**：
```cpp
void func(int& ref) {
    ref = 10; // 直接修改原变量
}
int main() {
    int a = 5;
	func(a); // a被修改为10
}
   ```

作用：直接修改原变量，语法简洁。

- **`const`引用传参**：

```cpp
void func(const int& ref) {
    // ref = 10; // 编译错误，const引用不可修改
}
int main() {
    int a = 5;
    func(a); // 只读访问a，原变量不会被修改
    // 也可直接传字面量或临时对象
    func(10); // 合法，临时对象会被绑定到const引用
}
    ```

作用：**只读访问原变量**，同时支持字面量、临时对象传参（避免拷贝开销），是函数传参的 “最优解” 之一。


#### 2. 传指针（`pass by pointer`）

```cpp
void func(int* p) {
    *p = 10; // 解引用后修改原变量
}
int main() {
    int a = 5;
    func(&a); // 传递a的地址
    // 也可传空指针（需注意空指针检查）
    int* p = nullptr;
    func(p); // 危险，需在函数内判断p是否为nullptr
}
```

作用：修改原变量，但语法需显式处理地址和解引用。

- **`const`指针传参**（两种场景）：
    
    - **指针指向的内容不可修改（`const int* p` 或 `int const* p`）**：

    ```cpp
        void func(const int* p) {
            // *p = 10; // 编译错误，不能修改指向的内容
            p = nullptr; // 可以修改指针本身的指向
    }
        ```
        
    - **指针本身不可修改（`int* const p`）**：

```cpp
    void func(int* const p) {
        *p = 10; // 可以修改指向的内容
        // p = nullptr; // 编译错误，指针本身不可修改
    }
```
        
- **指针和内容都不可修改（`const int* const p`）**：


```cpp
    void func(const int* const p) {
		// *p = 10; // 编译错误
		// p = nullptr; // 编译错误
    }
```

### 传引用与传指针的选择场景

|**场景**|**推荐方式**|**原因**|
|---|---|---|
|需修改原变量|传引用或传指针|两者都能实现，引用语法更简洁|
|需支持 “空值” 或 “可选参数”|传指针|指针可传`nullptr`表示无有效数据，引用无此能力|
|需只读访问且避免拷贝|传`const`引用|既保证原变量不被修改，又避免大对象拷贝的性能开销|
|底层操作（如内存管理）|传指针|指针更灵活，可直接操作地址、实现动态内存分配等底层逻辑|


# 地址开销

## 为什么`sizeof(引用)`等于原变量的大小？

引用的本质是 “变量的别名”，C++ 语法层面**刻意隐藏了它的底层实现细节**，让开发者可以像使用普通变量一样使用引用。

`sizeof`作为 “编译期运算符”，它计算的是**语法层面的类型大小**，而非底层实际存储的字节数：

- 对引用`T& ref`，编译器会直接将其解析为 “`T`类型的变量”，所以`sizeof(ref) = sizeof(T)`（和原变量大小一致）；
- 这是语法设计的 “抽象”，目的是让引用更易用，而非反映它的底层实现（多数编译器会用指针实现引用，底层占 8 字节 < 64 位系统 >，但语法上不暴露）。

而实际上，引用底层就是指针，忽略了很多细节的 **“语法糖”**

## 函数传入的超级优势
我们知道，函数传入是在拷贝实参赋值给形参，在内存中单独开辟一块地方出来
要是传入数据小还能接收，若是大对象，对内存开销非常大

引用和指针只有4字节，所以无论多大的对象只用4字节就能搞定，避免拷贝！
