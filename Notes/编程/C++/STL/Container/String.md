超标怪

# string怎么理解
string可以理解为由：
- char* buf：存字符的缓冲区
- size_t size：当前字符串长度
- size_t capacity：缓冲区已分配的总容量
- char* ptr：指向堆地址
组成，还有其他很多成员函数

超标在哪：
- string自动管理buf的扩容/释放；
- 内部有size记录，不依赖'\0'对数组操作；
- size会自动忽略'\0'
- 自动扩容
- 有一堆成员函数



# `std::string` 核心成员（按功能分类）

### 1. 构造与析构（创建 / 销毁字符串）
构造：
- 直接构造：string s("abc")或string s = “abc”
- 拷贝构造：string s（s2），深拷贝
- 移动构造：string s（std::move(s2)）浅拷贝，仅拷贝指针，性能最好

析构函数：`~string()`，自动释放动态内存（无需手动管理，避免内存泄漏）。

### 2. 赋值与交换（修改字符串内容）

|成员函数|功能说明|示例|
|---|---|---|
|`string& operator=(const string& rhs)`|拷贝赋值|`s1 = s2;`|
|`string& operator=(string&& rhs) noexcept`|移动赋值（C++11+）|`s1 = std::move(s2);`|
|`string& operator=(const char* cstr)`|用 C 字符串赋值|`s = "world";`|
|`string& operator=(char ch)`|用单个字符赋值|`s = 'a';`|
|`string& assign(...)`|重载版本的赋值（支持范围、n 个字符等）|`s.assign(3, 'y'); // "yyy"`|
|`void swap(string& other) noexcept`|交换两个字符串（高效，O (1) 时间）|`s1.swap(s2);`|

### 3. 元素访问（获取 / 修改单个字符）
  

| 函数 / 用法                 | 功能（对应 C 操作）                             | 性能                                |
| ----------------------- | --------------------------------------- | --------------------------------- |
| `s[i]`                  | 随机访问（类似 `s.buf[i]`）                     | O (1)（无越界检查，和 C 一样快）              |
| `s.at(i)`               | 带越界检查的访问（类似 `if (i < len) return s[i]`） | O (1)（检查开销可忽略）                    |
| `s.c_str()`/`s.data()`  | 返回 C 风格字符串（`\0` 结尾，类似 `return buf`）     | O (1)（仅返回指针）                      |
| `s.size()`/`s.length()` | 取长度（类似 `strlen(s.buf)`）                 | O (1)（直接返回存好的 size，比 `strlen` 快！） |
| `s.empty()`             | 判断空（类似 `len == 0`）                      | O (1)（比 `size() == 0` 直观，性能一样）    |

> 性能关键点：`s.size()` 是 O (1)，而 C 语言 `strlen` 是 O (n)（遍历计数），这是 `string` 比 C 字符数组的大优势！

### 4. 查找与比较（对应 C 的 `strstr`/`strcmp`）

| 函数 / 用法                  | 功能（对应 C 操作）                      | 性能                             | capacity 变化 |
| ------------------------ | -------------------------------- | ------------------------------ | ----------- |
| `s.find("abc", pos=0)`   | 从 pos 找 "abc" 第一次出现（类似 `strstr`） | O (n*k)（n 是 s 长度，k 是目标长度；最坏情况） | 无           |
| `s.rfind("abc")`         | 反向查找（类似 C 手动从末尾遍历）               | O(n*k)                         | 无           |
| `s == "abc"`/`s < "abc"` | 字典序比较（类似 `strcmp`）               | O (min (n,k))（比较到第一个不同字符）      | 无           |
| `s.compare("abc")`       | 比较（返回负数 / 0 / 正数，同 `strcmp`）     | O(min(n,k))                    | 无           |

> 性能关键点：`find` 是线性查找，大数据量（比如 10 万字符）查找频繁时，建议用更高效的算法（如 KMP），但日常场景 `find` 足够用；`string` 的比较运算符和 `strcmp` 性能一致，但更直观。
### 5. 字符串修改

| 函数 / 用法                              | 功能（对应 C 操作）                                | 性能                                 | capacity 变化                                    |
| ------------------------------------ | ------------------------------------------ | ---------------------------------- | ---------------------------------------------- |
| **拼接**                               |                                            |                                    |                                                |
| `s += "abc"`                         | 追加字符串（类似 `strcat`，但自动扩容）                   | O (k)（k 是追加长度；若需扩容，O (n+k)）        | 若 size + k ≤ capacity，不变；否则扩容（通常扩为原来的 1.5~2 倍） |
| `s.push_back('x')`                   | 追加单个字符（类似 `s[len++] = 'x'; s[len] = '\0'`） | O (1)（无扩容时）；O (n)（扩容时）             | 同上（按需扩容）                                       |
| `s.emplace_back('x')`                | 同上                                         | 直接在后面创建，性能很好                       | 同上                                             |
| `s.append('x')`                      | 同上，用重载的”+“理解                               |                                    | 同上                                             |
| **插入**                               |                                            |                                    |                                                |
| `s.insert(pos, "abc")`               | 在 pos 位置插入字符串（类似 C 手动移动字符 + 拷贝）            | O (n + k)（n 是原长度，k 是插入长度；移动字符开销大）  | 若 size + k ≤ capacity，不变；否则扩容                  |
| **删除**                               |                                            |                                    |                                                |
| `s.erase(iterator pos,iterator len)` | 从 pos 删 len 个字符（类似 C 手动移动字符覆盖）             | O (n)（移动后面的字符填补空白）                 | 不改变！（仅缩小 size，不释放多余内存）                         |
| `s.pop_back()`                       | 删最后一个字符（类似 `s[--len] = '\0'`）              | O (1)（仅改 size，无移动）                 | 不改变                                            |
| **替换**                               |                                            |                                    |                                                |
| `s.replace(pos, len, "xyz")`         | 替换 pos 开始的 len 个字符为 "xyz"                  | O (n)（若替换后总长度不变，直接覆盖；若变长，需移动 + 扩容） | 若新 size ≤ capacity，不变；否则扩容                     |

> 性能对比：C 语言手动实现插入 / 删除需要自己算偏移、移动字符，容易出错且性能和 `string` 差不多，但 `string` 更安全；`pop_back` 比 `erase(size-1, 1)` 快（O (1) vs O (n)），优先用。
>`push_back`有一个先在栈上创建新元素，在拷贝过来的过程，这对于大元素容器如[[Vector]]来说性能非常差劲，而`emplace_back`就直接在堆上创建
### 6. 容量管理（核心：控制 capacity 提升性能）

C 语言中你手动 `malloc` 时会预留足够空间避免频繁 `realloc`，`string` 也有对应的接口，这是优化性能的关键：

|函数 / 用法|功能（对应 C 操作）|性能|作用场景|
|---|---|---|---|
|`s.reserve(n)`|预分配容量 ≥n（类似 `realloc(s.buf, n+1)`，+1 留 `\0`）|O (1)（不扩容时）；O (n)（扩容时，拷贝旧字符）|提前知道要存多少字符（比如要拼接 1000 个字符），先 `reserve(1000)`，避免多次扩容|
|`s.shrink_to_fit()`|收缩容量到等于 size（类似 `realloc(s.buf, size+1)`）|O (n)（拷贝字符到新缓冲区）|删除大量字符后，释放多余内存（比如从 1000 字符删到 10 个，想回收内存）|
|`s.capacity()`|取当前容量（类似你记的 `malloc` 申请的大小）|O(1)|调试 / 性能优化时查看|

> 注意：
> 
> 1. `reserve(n)` 只 “增大” 容量，不 “缩小”（比如当前 capacity=100，`reserve(50)` 无效）；
> 2. `shrink_to_fit()` 是 “建议”，编译器可能忽略（比如某些实现为了性能不收缩）；
> 3. 性能优化技巧：如果要对 `string` 做大量拼接 / 插入，先 `reserve` 预估容量，能把多次扩容（O (n)）变成一次，性能提升巨大。

### 7. 转换函数（C 与 C++ 字符串 / 数值互转）

|函数 / 用法|功能（对应 C 操作）|性能|注意事项|
|---|---|---|---|
|`to_string(123)`|数值转 string（类似 `sprintf(buf, "%d", 123)`）|O (1)（固定长度数值）；O (n)（长数字）|支持 int/double 等，C 语言需手动 sprintf|
|`stoi(s)`/`stod(s)`|string 转数值（类似 `atoi(s.c_str())`）|O (n)（遍历字符串解析）|转换失败抛异常（比 `atoi` 安全，`atoi` 出错返回 0 无提示）|
|`s.c_str()`|string 转 C 字符串（`const char*`）|O (1)（返回指针）|指针有效期：直到 `s` 被修改（扩容 / 删除等）或销毁|

> 性能关键点：`to_string` 和 `sprintf` 性能差不多，但 `to_string` 更简洁；`stoi` 比 `atoi` 安全，但性能略低（异常检查开销），日常场景可忽略。