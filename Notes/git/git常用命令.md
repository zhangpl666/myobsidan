git很多命令和Linux相同
# 基础版本控制

| 命令名称                                | 作用       |
| ----------------------------------- | -------- |
| `git config --global user.name 用户名` | 设置用户签名   |
| `git config --global user.email 邮箱` | 设置用户邮箱   |
| `git init`                          | 初始化本地库   |
| `git status`                        | 查看本地库状态  |
| `git add 文件名`                       | 添加到缓存区   |
| `git commit -m "日志信息" 文件名`          | 提交到本地库   |
| `git reflog`                        | 查看历史记录   |
| `git reset --hard 版本号`              | 版本穿梭     |
| `git reset --soft 版本号`              | 移动HEAD指针 |
## 初始化本地库
终端进入指定文件夹，输入`git init`就可以初始化一个空的本地库
但这个目录默认是隐藏的，进入查看，勾选隐藏项目，即可查看
>[!warning]
>隐藏内容千万别修改！！

## 查看本地库状态
`git status`
初始状态下分支为master
在文件夹内的文件都是工作区，未被追踪，红色字体显示

## 添加到缓存区
`git add`加入缓存区，查看状态时显示为绿色，可删去
删除：`git rm 文件名`
删去后查看状态为红色
用==`git add .`==命令一次性添加当前文件夹中所有文件到缓存区（.gitignore中的除外）
**删除的内容必须用git rm命令才能提交上去**

## 提交本地库 
`git commit -m "日志信息" 文件名`
-m：提交版本日志信息，不加也会要求加，所以还是加上吧
提交后，查看状态时可以看到版本号

## 查看信息
用`git reflog`查看版本信息，`git log`查看详细信息

## 版本穿梭
实质是改变head指针和master的指向，hard为永久性改变，删掉目前版本
soft仅仅移动HEAD指针，还可以移动回来
### 仅查看旧版本

```bash
git checkout <commit ID>  # 切换到指定版本
```

- **效果**：临时 “跳回” 到该版本的状态，此时：
    - 工作区会显示该版本的文件内容；
    - 缓存区会被重置为该版本的状态；
    - 但这是 “临时查看”，Git 会提示你处于 “分离 HEAD 状态”（不是在任何分支上）。
- **退出方式**：切换回原来的分支（如 `git checkout main`），工作区和缓存区会自动恢复到切换前的状态（未提交的修改会保留）。

### 彻底恢复到旧版本

```bash
git reset --hard <commit ID>  # 强制重置到指定版本
```

- **效果**：将当前分支的指针直接移动到目标版本，同时：
    - 工作区的所有文件会被替换为该版本的内容（**当前未提交的修改会被彻底删除**）；
    - 缓存区会被清空并重置为该版本的状态；
- **风险**：这是 “破坏性操作”，会丢失所有在目标版本之后的本地修改（包括工作区和缓存区的内容），使用前务必确认。

### 温和恢复


```bash
git reset --soft <commit ID>  # 软重置到指定版本
```

- **效果**：仅将当前分支的指针移动到目标版本，撤销目标版本后面的提交：
    - 工作区和缓存区会被保留（不会被覆盖）；
- **用途**：通常用于 “撤销最近几次提交”，但保留修改内容（比如提交错了，想重新整理后再提交）。

```bash
git reset --mixed <commit ID> #这也是reset的默认
```
- **效果**：与soft差不多，区别：
	- 缓存区会重置为目标版本；
	- 但工作区不会变，重新add就好了

### 更加保险
```bash
git revert <commit ID> #会新建commit
#这里的commit ID指向要撤销的更改
```
**这里的commit ID指向要撤销的更改**
- **效果**：会在分支指针后面新建一个版本，会撤销指定提交的所有更改
	- HEAD指针移动到新版本
![[Pasted image 20251119182318.png]]

---
# 分支操作

## 创建分支
`git branch 分支名`
创建后HEAD指针并没有改变
`git checkout -b 分支名`
创建一个新的分支并直接将头指针指向新分支，相当于`git branch + git checkout`
`git switch`同理

## 查看分支
`git branch -v`
显示分支数、名称、最新版本日志和版本号
不加-v的话只有分支名
## 切换分支
`git checkout 分支名`
切换分支后用`git branch -v`查看，HEAD指向的分支为绿色字体
[[Checkout命令]]
- `git checkout` 功能过于复杂（既切换分支，又操作文件），新增两个命令拆分其职责。
- `git switch <分支名>`：专门用于切换分支（替代 `git checkout <分支>`），例如：
    ```bash
    git switch feature-branch  # 切换到 feature-branch
    git switch -c new-branch   # 创建并切换到新分支（类似 checkout -b）
    ```
    
- `git restore <文件>`：用于恢复工作区文件（替代 `git checkout -- <文件>`），例如：
  ```bash
    git restore README.md  # 用暂存区内容覆盖工作区的 README.md
    git restore --staged README.md  # 取消暂存（将暂存区的修改放回工作区，替代 reset HEAD）
    ```


## 合并分支
是将指定分支合并到当前HEAD所在文件上
如果没有冲突，自动合并
如果有冲突，会提醒人工合并并添加到暂存区，但提交时不能带有文件名
两种合并策略：
### 1、merge策略
命令：`git merge 分支名`
直接在头指针指向的分支上新建commit，集成两个分支的修改
![[Pasted image 20251119174849.png]]
### 2、rebase策略
命令：`git rebase 分支名`
将指定分支的提交移动到头指针指向的分支的最新位置
![[Pasted image 20251119175141.png]]

---
# 本地库与远程库
## 创建远程库
create a new repository
远程库是基于账号的，同名不影响
公共库：完全开源
私有库：团队内不能超过五个人

每个远程库有一个链接，链接很不好记

 创建远程库别名，用别名替代链接
`git remote add 别名 远程地址`
`git remote -v`查看当前所有远程地址别名
一个别名会创建两个文件，一个用来fetch，一个用来pull
## 推送本地库到远程库
**只能以分支为最小push单位**
基本语法：`git push 链接/别名 要推送的分支`

## 拉取远程库到本地库
基本语法：`git pull 链接/别名 要拉取的分支`
拉取会自动上传
`git pull`并非单一操作，而是 **`git fetch`（拉取远程最新代码到本地缓存区）** + **`git merge`（将远程代码合并到本地当前分支）** 的组合命令

若本地库没有修改，远程库是本地库的直接后续，则直接合并，即本地分支指针直接指向远程分支，没有新的commit

若本地库和远程库合并有冲突，会自动创建一个新commit，手动执行合并并commit

## 克隆远程库到本地
基本语法：`git clone 链接/别名`
clone干了三件事：
* 拉取代码
* 初始化本地库
* 创建别名（默认为origin）



