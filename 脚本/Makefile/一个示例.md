这是一个完整的Makefile文件，支持动态库、静态库的选择

project结构如下：
```explain
project
	|Makefile
	|src ：储存源文件
	|build/release（debug）：储存.o文件和.d文件
	|lib :储存库

```


```Makefile
# ================== 编译器与工具 ==================
CXX      := g++
AR       := ar
RM       := rm -rf

# ================== 构建模式 ==================
# 用法：
#   make MODE=debug
#   make MODE=release
MODE ?= release

# 用法：
#   make LIB_TYPE=static
#   make LIB_TYPE=shared
LIB_TYPE ?= shared

# ================== 目录结构 ==================
SRC_DIR   := src
BUILD_DIR := build/$(MODE)
LIB_DIR   := lib

# ================== 源文件 ==================
APP_SRC := $(SRC_DIR)/main.cpp
LIB_SRC := $(SRC_DIR)/add.cpp

# ================== 目标文件 ==================
APP_OBJ := $(BUILD_DIR)/main.o
LIB_OBJ := $(BUILD_DIR)/add.o

# ================== 库名 ==================
LIB_NAME := add
STATIC_LIB := $(LIB_DIR)/lib$(LIB_NAME).a
SHARED_LIB := $(LIB_DIR)/lib$(LIB_NAME).so

# ================== 编译选项 ==================
CXXFLAGS_COMMON := -std=c++20 -Wall -MMD -MP

ifeq ($(MODE),debug)
	CXXFLAGS := $(CXXFLAGS_COMMON) -g -O0
else
	CXXFLAGS := $(CXXFLAGS_COMMON) -O2
endif

# 动态库需要 PIC
ifeq ($(LIB_TYPE),shared)
	CXXFLAGS += -fPIC
endif
# ================== 库选择 ==================
ifeq ($(LIB_TYPE),static)
	LIB_TARGET := $(STATIC_LIB)
else
	LIB_TARGET := $(SHARED_LIB)
endif

# ================== 链接选项 ==================
LDFLAGS :=
LDLIBS  := -L$(LIB_DIR) -l$(LIB_NAME)

# 运行时找到动态库（rpath）
ifeq ($(LIB_TYPE),shared)
	LDFLAGS += -Wl,-rpath,'$$ORIGIN/$(LIB_DIR)'
endif

# ================== 最终目标 ==================
.PHONY: all clean info
all: info app

info:
	@echo "MODE     = $(MODE)"
	@echo "LIB_TYPE = $(LIB_TYPE)"

# ================== 可执行文件 ==================
app: $(APP_OBJ) $(LIB_TARGET)
	$(CXX) $(APP_OBJ) $(LDFLAGS) $(LDLIBS) -o $@



# ================== 静态库 ==================
$(STATIC_LIB): $(LIB_OBJ)
	@mkdir -p $(LIB_DIR)
	$(AR) rcs $@ $<

# ================== 动态库 ==================
$(SHARED_LIB): $(LIB_OBJ)
	@mkdir -p $(LIB_DIR)
	$(CXX) -shared $< -o $@

# ================== 编译规则 ==================
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp
	@mkdir -p $(BUILD_DIR)
	$(CXX) $(CXXFLAGS) -c $< -o $@

# ================== 依赖文件 ==================
DEPS := $(APP_OBJ:.o=.d) $(LIB_OBJ:.o=.d)
-include $(DEPS)

# ================== 清理 ==================
clean:
	$(RM) build lib app
```

```Makefile

CXX = g++
CXXFLAGS = -std=c++20 -Wall -MMD -MP

SRC_DIR = src
BUILD_DIR = build
LIB_DIR = lib

SRC = $(wildcard $(SRC_DIR)/*.cpp)
LIB_OBJ = $(BUILD_DIR)/add.o
APP_OBJ = $(BUILD_DIR)/main.o
LIB_NAME = add

STATIC_LIB = $(LIB_DIR)/lib$(LIB_NAME).a
SHARED_LIB = $(LIB_DIR)/lib$(LIB_NAME).so
LIB_TYPE ?= shared
LDFLAGS = 
LDLIBS = -L$(LIB_DIR) -l$(LIB_NAME)

ifeq ($(LIB_TYPE), shared)
	LDFLAGS += -Wl,-rpath='$(LIB_DIR)'
	LIB_TARGET = $(SHARED_LIB)
	CXXFLAGS += -fPIC
else
	LIB_TARGET = $(STATIC_LIB)
endif	

.PHONY : clean

app : $(APP_OBJ) $(LIB_TARGET)
	$(CXX) $< $(LDFLAGS) $(LDLIBS)  -o $@

$(STATIC_LIB): $(LIB_OBJ)
	@mkdir -p $(LIB_DIR)
	ar rcs $@ $^

$(SHARED_LIB): $(LIB_OBJ)
	@mkdir -p $(LIB_DIR)
	$(CXX) -shared $^ -o $@

$(BUILD_DIR)/%.o : $(SRC_DIR)/%.cpp
	@mkdir -p $(BUILD_DIR)
	$(CXX) $(CXXFLAGS) -c $< -o $@

clean :
	rm -rf build app lib

-include $(BUILD_DIR)/*.d
```